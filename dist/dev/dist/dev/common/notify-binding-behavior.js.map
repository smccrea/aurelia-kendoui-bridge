{"version":3,"sources":["common/notify-binding-behavior.js"],"names":["EventManager","inject","NotifyBindingBehavior","eventManager","bind","binding","scope","target","fieldName","updateSource","targetObserver","observerLocator","getObserver","targetProperty","originalHandler","handler","createElementHandler","observable","source","bindingContext","field","sourceExpression","expression","name","intercept","value","set","trigger","setTimeout","call","dirty","unbind"],"mappings":";;;;;;;;;;;;;AAAQA,kB,mBAAAA,Y;;AACAC,Y,+BAAAA,M;;;uCAGKC,qB,WADZD,OAAOD,YAAP,C;AAEC,uCAAYG,YAAZ,EAA0B;AAAA;;AACxB,eAAKA,YAAL,GAAoBA,YAApB;AACD;;wCAEDC,I,iBAAKC,O,EAASC,K,EAAOC,M,EAAQC,S,EAAW;AACtC,cAAI,CAACH,QAAQI,YAAb,EAA2B;;AAG3B,cAAIC,iBAAiBL,QAAQM,eAAR,CAAwBC,WAAxB,CAAoCP,QAAQE,MAA5C,EAAoDF,QAAQQ,cAA5D,CAArB;AACAR,kBAAQK,cAAR,GAAyBA,cAAzB;AACAA,yBAAeI,eAAf,GAAiCT,QAAQK,cAAR,CAAuBK,OAAxD;AACA,cAAIA,UAAU,KAAKZ,YAAL,CAAkBa,oBAAlB,CAAuC,CAAC,MAAD,CAAvC,CAAd;AACAN,yBAAeK,OAAf,GAAyBA,OAAzB;;AAEA,cAAIE,aAAaV,UAAUF,QAAQa,MAAR,CAAeC,cAA1C;AACA,cAAIC,QAAQZ,aAAaH,QAAQgB,gBAAR,CAAyBC,UAAzB,CAAoCC,IAA7D;AACA,cAAIC,YAAYnB,QAAQI,YAAxB;;AAIAJ,kBAAQ,0BAAR,IAAsCmB,SAAtC;AACAnB,kBAAQI,YAAR,GAAuB,UAASgB,KAAT,EAAgB;AAErC,gBAAIR,WAAWS,GAAX,IAAkBT,WAAWU,OAAjC,EAA0C;AAIxCC,yBAAW;AAAA,uBACTX,WAAWU,OAAX,CAAmBE,IAAnB,CAAwBZ,UAAxB,EAAoC,QAApC,EAA8C,EAAEG,OAAOA,KAAT,EAA9C,CADS;AAAA,eAAX,EAEA,GAFA;;AAIA,kBAAIH,WAAWa,KAAX,KAAqB,KAAzB,EAAgC;AAC9Bb,2BAAWa,KAAX,GAAmB,IAAnB;AACD;AACF;;AAED,mBAAON,UAAUK,IAAV,CAAexB,OAAf,EAAwBoB,KAAxB,CAAP;AACD,WAhBD;AAiBD,S;;wCAEDM,M,mBAAO1B,O,EAASC,K,EAAO;AACrB,cAAI,CAACD,QAAQ,0BAAR,CAAL,EAA0C;;AAE1CA,kBAAQI,YAAR,GAAuBJ,QAAQ,0BAAR,CAAvB;AACAA,kBAAQ,0BAAR,IAAsC,IAAtC;AACD,S","file":"common/notify-binding-behavior.js","sourceRoot":"/source/","sourcesContent":["import {EventManager} from 'aurelia-binding';\nimport {inject} from 'aurelia-dependency-injection';\n\n@inject(EventManager)\nexport class NotifyBindingBehavior {\n  constructor(eventManager) {\n    this.eventManager = eventManager;\n  }\n\n  bind(binding, scope, target, fieldName) {\n    if (!binding.updateSource) return;\n\n    // update values on blur event\n    let targetObserver = binding.observerLocator.getObserver(binding.target, binding.targetProperty);\n    binding.targetObserver = targetObserver;\n    targetObserver.originalHandler = binding.targetObserver.handler;\n    let handler = this.eventManager.createElementHandler(['blur']);\n    targetObserver.handler = handler;\n\n    let observable = target || binding.source.bindingContext;\n    let field = fieldName || binding.sourceExpression.expression.name;\n    let intercept = binding.updateSource;\n\n    // intercept updateSource function\n    // to call .trigger('change', { field: field}) and set the dirty flag\n    binding['intercepted-updateSource'] = intercept;\n    binding.updateSource = function(value) {\n      // handle change\n      if (observable.set && observable.trigger) {\n        // kendo recompiles templates after a change event\n        // without this delay Aurelia's binding system gets confused as\n        // some views are destroyed\n        setTimeout(() =>\n          observable.trigger.call(observable, 'change', { field: field }),\n        100);\n\n        if (observable.dirty === false) {\n          observable.dirty = true;\n        }\n      }\n\n      return intercept.call(binding, value);\n    };\n  }\n\n  unbind(binding, scope) {\n    if (!binding['intercepted-updateSource']) return;\n\n    binding.updateSource = binding['intercepted-updateSource'];\n    binding['intercepted-updateSource'] = null;\n  }\n}\n"]}