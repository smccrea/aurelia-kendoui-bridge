{"version":3,"sources":["common/notify-binding-behavior.js"],"names":["EventManager","inject","NotifyBindingBehavior","eventManager","bind","binding","scope","target","fieldName","updateSource","targetObserver","observerLocator","getObserver","targetProperty","originalHandler","handler","createElementHandler","observable","source","bindingContext","field","sourceExpression","expression","name","intercept","value","set","trigger","setTimeout","call","dirty","unbind"],"mappings":";;;;;;;;;;;;;AAAQA,kB,mBAAAA,Y;;AACAC,Y,+BAAAA,M;;;uCAGKC,qB,WADZD,OAAOD,YAAP,C;AAEC,uCAAYG,YAAZ,EAA0B;AAAA;;AACxB,eAAKA,YAAL,GAAoBA,YAApB;AACD;;wCAEDC,I,iBAAKC,O,EAASC,K,EAAOC,M,EAAQC,S,EAAW;AACtC,cAAI,CAACH,QAAQI,YAAb,EAA2B;;AAG3B,cAAIC,iBAAiBL,QAAQM,eAAR,CAAwBC,WAAxB,CAAoCP,QAAQE,MAA5C,EAAoDF,QAAQQ,cAA5D,CAArB;AACAR,kBAAQK,cAAR,GAAyBA,cAAzB;AACAA,yBAAeI,eAAf,GAAiCT,QAAQK,cAAR,CAAuBK,OAAxD;AACA,cAAIA,UAAU,KAAKZ,YAAL,CAAkBa,oBAAlB,CAAuC,CAAC,MAAD,CAAvC,CAAd;AACAN,yBAAeK,OAAf,GAAyBA,OAAzB;;AAEA,cAAIE,aAAaV,UAAUF,QAAQa,MAAR,CAAeC,cAA1C;AACA,cAAIC,QAAQZ,aAAaH,QAAQgB,gBAAR,CAAyBC,UAAzB,CAAoCC,IAA7D;AACA,cAAIC,YAAYnB,QAAQI,YAAxB;;AAIAJ,kBAAQ,0BAAR,IAAsCmB,SAAtC;AACAnB,kBAAQI,YAAR,GAAuB,UAASgB,KAAT,EAAgB;AAErC,gBAAIR,WAAWS,GAAX,IAAkBT,WAAWU,OAAjC,EAA0C;AAIxCC,yBAAW;AAAA,uBACTX,WAAWU,OAAX,CAAmBE,IAAnB,CAAwBZ,UAAxB,EAAoC,QAApC,EAA8C,EAAEG,OAAOA,KAAT,EAA9C,CADS;AAAA,eAAX,EAEA,GAFA;;AAIA,kBAAIH,WAAWa,KAAX,KAAqB,KAAzB,EAAgC;AAC9Bb,2BAAWa,KAAX,GAAmB,IAAnB;AACD;AACF;;AAED,mBAAON,UAAUK,IAAV,CAAexB,OAAf,EAAwBoB,KAAxB,CAAP;AACD,WAhBD;AAiBD,S;;wCAEDM,M,mBAAO1B,O,EAASC,K,EAAO;AACrB,cAAI,CAACD,QAAQ,0BAAR,CAAL,EAA0C;;AAE1CA,kBAAQI,YAAR,GAAuBJ,QAAQ,0BAAR,CAAvB;AACAA,kBAAQ,0BAAR,IAAsC,IAAtC;AACD,S","file":"common/notify-binding-behavior.js","sourceRoot":"/source/","sourcesContent":["import {EventManager} from 'aurelia-binding';\r\nimport {inject} from 'aurelia-dependency-injection';\r\n\r\n@inject(EventManager)\r\nexport class NotifyBindingBehavior {\r\n  constructor(eventManager) {\r\n    this.eventManager = eventManager;\r\n  }\r\n\r\n  bind(binding, scope, target, fieldName) {\r\n    if (!binding.updateSource) return;\r\n\r\n    // update values on blur event\r\n    let targetObserver = binding.observerLocator.getObserver(binding.target, binding.targetProperty);\r\n    binding.targetObserver = targetObserver;\r\n    targetObserver.originalHandler = binding.targetObserver.handler;\r\n    let handler = this.eventManager.createElementHandler(['blur']);\r\n    targetObserver.handler = handler;\r\n\r\n    let observable = target || binding.source.bindingContext;\r\n    let field = fieldName || binding.sourceExpression.expression.name;\r\n    let intercept = binding.updateSource;\r\n\r\n    // intercept updateSource function\r\n    // to call .trigger('change', { field: field}) and set the dirty flag\r\n    binding['intercepted-updateSource'] = intercept;\r\n    binding.updateSource = function(value) {\r\n      // handle change\r\n      if (observable.set && observable.trigger) {\r\n        // kendo recompiles templates after a change event\r\n        // without this delay Aurelia's binding system gets confused as\r\n        // some views are destroyed\r\n        setTimeout(() =>\r\n          observable.trigger.call(observable, 'change', { field: field }),\r\n        100);\r\n\r\n        if (observable.dirty === false) {\r\n          observable.dirty = true;\r\n        }\r\n      }\r\n\r\n      return intercept.call(binding, value);\r\n    };\r\n  }\r\n\r\n  unbind(binding, scope) {\r\n    if (!binding['intercepted-updateSource']) return;\r\n\r\n    binding.updateSource = binding['intercepted-updateSource'];\r\n    binding['intercepted-updateSource'] = null;\r\n  }\r\n}\r\n"]}